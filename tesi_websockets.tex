 %\documentclass[12pt,a4paper,oneside]{report}

\documentclass[12pt,a4paper,openright]{report}

\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{upquote}
\usepackage{framed,xcolor,verbatim}
\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
\definecolor{editorGray}{rgb}{0.98, 0.98, 0.98}
\definecolor{editorOcher}{HTML}{FF7F00}
\definecolor{green}{HTML}{0D9E0D}
\definecolor{orange}{HTML}{CF7B2F}
\definecolor{red}{HTML}{D53235}
\definecolor{olive}{rgb}{0.17,0.59,0.20}
\definecolor{brown}{rgb}{0.69,0.31,0.31}
\definecolor{purple}{HTML}{BC5298}
\definecolor{lightblue}{rgb}{0.1,0.57,0.7}
\definecolor{lightred}{rgb}{1,0.4,0.5}

% JavaScriptnpm sta
\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, true, try, typeof, var, void, while, with, const, let},
  ndkeywords={class, export, boolean, throw, implements, import, this},
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morestring=[b]",
  morestring=[b]`,
  morestring=[b]',
  % Code design
  identifierstyle=\color{black},
  keywordstyle=\color{purple}\bfseries,
  ndkeywordstyle=\color{red}\bfseries,
  stringstyle=\color{green}\ttfamily,
  commentstyle=\color{darkgray}\ttfamily,
}
\lstset{
   language=JavaScript,
   backgroundcolor=\color{editorGray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\tiny,
   numbersep=9pt,
   frameround=tttt,
   frame=single,
   tabsize=3,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

%\usepackage[latin1]{inputenc}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{natbib}
\usepackage{newlfont}
\usepackage{hyperref}
\usepackage{url}

\definecolor{shadecolor}{rgb}{.9, .9, .9}

\newenvironment{code}%
   {\snugshade\verbatim}%
   {\endverbatim\endsnugshade}

\usepackage{graphicx}
\usepackage{svg}
\usepackage{afterpage}

\newcommand\blankpage{%
    \null
    \thispagestyle{empty}%
    \addtocounter{page}{-1}%
    \newpage}

%\usepackage{showkeys} serve per mostrare le etichette, va tolta per la versione definitiva;
%\linespread{1.3}
\oddsidemargin=0pt
\textwidth= 450pt
\hyphenation{} %serve per la sillabazione
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\setlength{\parindent}{0pt}

\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
						% Frontespizio
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
\begin{center}
{{\Large{\textsc{Alma Mater Studiorum $\cdot$ Universit\`a di
Bologna}}}} \rule[0.1cm]{15.8cm}{0.1mm}
\rule[0.5cm]{15.8cm}{0.6mm}
{\small{\bf SCUOLA DI SCIENZE\\
  Corso di Laurea in Informatica }}
  \end{center}
  \vspace{40mm}
  \begin{center}
  {\LARGE{\bf Resource-centric push model over WebSockets}}\\
  \end{center}
  \vspace{40mm}
  \par
  \noindent
  \begin{minipage}[t]{0.47\textwidth}
  {\large{\bf Relatore:\\
  Chiar.mo Prof.\\
  Fabio Vitali}}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.47\textwidth}\raggedleft
  {\large{\bf Presentata da:\\
  Filippo Vigani}}
  \end{minipage}
  \vspace{30mm}
  \begin{center}
  {\large{\bf Sessione I\\%inserire il numero della sessione in cui ci si laurea
  Anno Accademico 2018-2019}}%inserire l'anno accademico a cui si è iscritti
  \end{center}
  \end{titlepage}
  \pagenumbering{roman}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  							% Dedica
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \cleardoublepage

  \cleardoublepage
  \thispagestyle{empty}
  \vspace*{\stretch{1}}
  \large                                  %aumenta la grandezza del carattere a 14pt
  \begin{flushright}
  \em
  \itshape

  \end{flushright}
  \vspace{\stretch{2}}
  \cleardoublepage


  \afterpage{\blankpage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
							% Indice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{roman}\normalsize
\clearpage{\pagestyle{empty}\cleardoublepage}
\tableofcontents
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}

\listoffigures
\addcontentsline{toc}{chapter}{Lista delle figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
							% Introduzione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Introduzione}
\rhead[\fancyplain{}{\bfseries
INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INTRODUZIONE}}
\addcontentsline{toc}{chapter}{Introduzione}
Quando si sviluppa un’applicazione web, si deve considerare che meccanismo di data delivery utilizzare. Spesso si vuole sviluppare un’applicazione che lavori con dati in tempo reale: può essere una dashboard con l’andamento di un mercato azionario, o una console di un servizio backend su cui lavorano più utenti, o ancora un semplice calendario condiviso per la gestione di appuntamenti.

\bigskip

Per molto tempo l’unica modalità per reperire i dati da un web browser è stata tramite client pull, ovvero il client si occupa di richiedere una risorsa, e richiedere se la risorsa stessa sia stata modificata.

\bigskip

Con l’implementazione dei websocket nella maggior parte dei browser, la situazione cambia. Si apre la possibilità di ricevere dati tramite server push, senza dover periodicamente richiedere una risorsa, ma lasciando al server l’onere di notificare i client dell’avvenuta modifica della risorsa.

\bigskip

Tuttavia i websocket rimangono un’implementazione di basso livello, e lavorarci su applicazioni di alto livello, dove l’architettura e la separation of concerns è un punto focale, risulta complesso.

\bigskip

La soluzione proposta permette in modo semplice ed intuitivo di rimanere in ascolto di una risorsa come se fosse un endpoint REST, e ogni qualvolta questa risorsa venga aggiornata, essere notificati del nuovo contenuto, senza doversi preoccupare di una gestione efficiente delle risorse.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
							% Background
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}

Nello sviluppo di applicazioni web moderne spesso si ha la necessità di aggiornare parti dell’interfaccia in modo che rispecchino delle risorse non presenti localmente in tempo reale. Si pensi per esempio ad un’applicazione che deve visualizzare i dati dello stock market, o ad un social network, o ad un calendario per la gestione degli appuntamenti, o ancora ad una semplice dashboard di gestione aziendale. 

\bigskip

In tutti questi casi, poter vedere le modifiche effettuate da terzi sulle stesse risorse in real-time è essenziale o migliora di gran lunga la user experience. Le applicazioni real-time stanno gradualmente dominando l’internet in quanto forniscono un perfetto equilibrio di informazioni, funzionalità, contenuto e interattività che portano ad aumentare lo user engagement.

%%%%%%%%%%%%%%%%%%%%%%%%%
			% Sviluppo app moderne real-time
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sviluppo app moderne real-time}\label{sec_appmoderne}

Con applicazioni real-time intendiamo applicazioni che permettano di ricevere e visualizzare degli aggiornamenti che risiedono su un server nel minor tempo possibile. Da una definizione così banale, spuntano in realtà una serie di questioni importanti per quanto concerne sia le tecnologie per implementarle, che le tecniche utilizzate che la gestione delle risorse.

\bigskip

Gli sviluppatori web, fino a qualche anno fa, per ottenere dei risultati simili hanno dovuto sfruttare diverse tecniche che aggirassero le limitazioni dei browser. Infatti l’unico modo di ricevere dati per un browser era quello di inviare una richiesta al server, e ricevere una risposta. Ciò significa che il client non aveva modo di essere notificato in caso la risorsa richiesta venisse modificata.

%%%%%%%%%%%%%%%%%%%%%%%%%
			% Client pull
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Client pull}\label{sec_clientpull}

Questo stile di comunicazione ove la richiesta è originata dal client e risposta dal server è chiamato \textit{client pull}. Il client pull forma la base per la comunicazione tra un browser e un server tramite il protocollo HTTP, e su di esso si sono costruiti una serie di stili architetturali per fornire interoperabilità tra web services in maniera prestabilita. Per esempio, uno degli stili più utilizzati è REST (REpresentational State Transfer), che stabilisce che i web services devono permettere ad altri sistemi di richiedere l’accesso o la manipolazione di rappresentazioni testuali di risorse web usando un insieme predefinito di operazioni stateless.

\bigskip

Un protocollo stateless prevede che il server non mantenga nessuna informazione riguardante la connessione attiva del client tra una richiesta e l’altra. Non mantenendo alcun tipo di informazione sulla sessione, ne consegue che per verificare se una risorsa è stata aggiornata rispetto a quella salvata da un browser in precedenza, è necessario richiedere la stessa risorsa e compararla con la precedente.

%%%%%%%%%%%%%%%%%%%%%%%%%
		% Polling e long polling
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Polling e long polling}

Una delle tecniche largamente utilizzate per verificare se una risorsa, web o meno, sia stata modificata è appunto richiedere la stessa risorsa a intervalli regolari, e confrontarla con la precedente. Questa tecnica nella letteratura è chiamata polling. Nell’ambito dei web services e di HTTP, si possono distinguere due tipi di polling: Polling semplice e long polling
\begin{description}
\item Nel \textbf{polling semplice} la risorsa viene richiesta periodicamente e il server risponde immediatamente con la risorsa richiesta. Ad un livello più basso, viene aperta una connessione, inviato un messaggio dal client al server contenente la richiesta, inviato un messaggio di risposta dal server al client contenente la risorsa, e la connessione viene chiusa. Successivamente, dopo un periodo di polling prestabilito, si ripete.
Un esempio di utilizzo di polling client side potrebbe essere il seguente:
\lstinputlisting[caption=Client side XHR polling example]{snippets/polling_sample.js}

\begin{figure}[htbp]
\centering
\includegraphics[width=.5\textwidth]{assets/polling.png}
\caption{Polling}
\end{figure}

\item Nel caso del \textbf{long polling}, conosciuto anche come \textit{hanging GET} o \textit{COMET}, invece, il client invia una richiesta ad una risorsa specifica. Il server, invece di rispondere immediatamente, tiene aperta la connessione fintanto che la risorsa non viene aggiornata o finché una soglia di timeout viene superata. Quando sono presenti nuovi dati, il server risponde alla richiesta chiudendo la connessione di conseguenza. Dopodiché il client richiede nuovamente la stessa risorsa e rimane in attesa.
Questo flusso può essere implementato come l'esempio seguente:
\lstinputlisting[caption=Client side XHR long polling example]{snippets/longpolling_sample.js}

\begin{figure}[htbp]
\centering
\includegraphics[width=.5\textwidth]{assets/long_polling.png}
\caption{Long polling}
\end{figure}

A differenza del polling semplice, dove l’implementazione riguarda solo la parte client, e il server espone un semplice endpoint REST, nel long polling il server deve supportare questo tipo di interazione con il client. Infatti, oltre ad esporre un semplice endpoint REST, dovrà esporre un endpoint che si occupa di mantenere il client in attesa, ed inviare la risposta solo una volta che viene aggiornata la risorsa. Inoltre, dovrà gestire lo stato di connessioni multiple, ed implementare strategie per preservare lo stato delle sessioni quando si utilizzano più server e load balancers.

\end{description}

\subsection{Problematiche}
Entrambe le tecniche di polling sono dei workaround dovute alle storiche limitazioni dei browser e di HTTP, e dunque presentano delle problematiche. 
% Consumo di banda e traffico dati
\subsubsection{Consumo di banda e traffico dati}
Poiché il polling richiede ad intervalli regolari la stessa risorsa, spreca traffico dati per passare sia la richiesta della risorsa stessa, che per ricevere il payload effettivo. In particolare per ogni richiesta HTTP, deve essere stabilita una nuova connessione, si deve fare il parsing degli header HTTP, si deve presumibilmente reperire i dati da un database, e infine inviare i dati al client.

% Ritardo
\subsubsection{Ritardo}
Per limitare questo consumo, si cerca di trovare un equilibrio riducendo la frequenza di poll. Ma così facendo, risulta che per ricevere un aggiornamento di una risorsa, il client potrebbe aspettare fino alla durata dell’intervallo di tempo tra una richiesta e la successiva.

% Incoerenza dei dati
\subsubsection{Incoerenza dei dati}
Nel caso del long polling, la risorsa viene inviata presumibilmente appena subisce delle modifiche. Tuttavia nel lasso di tempo che passa tra quando il client riceve una risposta, ed effettua la nuova richiesta da tenere aperta, la risorsa stessa potrebbe essere modificata. In tal caso, il server non ha nessuna connessione in sospeso con il client, ed esso perderebbe l’aggiornamento. 

% Performance e scalabilità
\subsubsection{Performance e scalabilità}
Con l’aumentare del numero di client connessi, il numero di richieste rapportate al tempo invece di incrementare linearmente si moltiplica, in quanto ogni client per la stessa risorsa non effettuerà una singola richiesta, ma richieste multiple. Ciò rende i sistemi che implementano supportano polling difficili da scalare e poco performanti.

%%%%%%%%%%%%%%%%%%%%%%%%%
			% Server push
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Server push}\label{sec_serverpush}
A differenza del client pull, il server push è uno stile di comunicazione che prevede che sia il server a inviare ad un client dei dati, senza che una richiesta venga inviata in precedenza da parte del client. I servizi che supportano server push, spesso si basano su delle preferenze espresse dal client in precedenza. Questo modello è chiamato publish/subscribe. Un client esprime di voler ricevere gli aggiornamenti ad una risorsa o “channel”, e il server si occupa di inviare la risorsa a tale channel ogni volta che viene modificata.

\bigskip

Prima di HTML5, non era possibile implementare un modello publish/subscribe che funzionasse sulle applicazioni web, se non tramite astrazioni basate su polling. Con l’arrivo di HTML living standard e diverse tecnologie web, è ora possibile implementare sistemi connection-based per lo scambio di dati in real-time.

%%%%%%%%%%%%%%%%%%%%%%%%%
    % Server Sent Events
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Server Sent Events}
I Server Sent Events (SSE) sono una tecnologia push che permette ad un browser di ricevere aggiornamenti da un server tramite una connessione HTTP tramite una comunicazione simplex\footnote{in un'unica direzione}. L'API che offre questa funzionalità, chiamata \textit{EventSource API}, è standardizzata dal W3C come parte di HTML5.

Il flusso di una comunicazione basata su EventSource è il seguente\cite{eventsource_api}, sintetizzato in figura \ref{fig:server_sent_events}.

\begin{enumerate}
  \item Il client tramite la chiamata API \lstinline{new EventSource('/api/myEndpoint')} apre una nuova connessione HTTP.
  \item Il client registra le callback agli eventi \lstinline{onmessage}, \lstinline{onopen} e \lstinline{onerror}.
  \item Il server risponde alla prima richiesta specificando nell'header \lstinline{Content-Type} il tipo \lstinline{text/event-stream}.
  \item Il client, se supporta la EventSource API, mantiene la connessione aperta in attesa di nuovi messaggi.
  \item Il server può dunque inviare quando desidera un nuovo messaggio, finché la connessione non viene chiusa da una delle due parti.
\end{enumerate}

\begin{figure}[!htbp]
\centering
\includegraphics[width=.5\textwidth]{assets/server_sent_events.png}
\caption{Server Sent Events Flow}
\label{fig:server_sent_events}
\end{figure}

Un esempio di utilizzo di quest'API è il seguente:
\lstinputlisting[caption=Client side EventSource example]{snippets/eventsource_sample.js}

La limitazione di questa tecnologia è che una volta aperta una connessione, il client non potrà sfruttare la stessa per inviare ulteriori messaggi. Ciò significa che per rimanere in ascolto di diverse risorse in instanti differenti, sarà necessario aprire più connessioni. Se invece il server supporta HTTP/2, SSE potrà sfruttare il multiplexing offerto da HTTP/2 automaticamente.
Inoltre, al momento di questa stesura, nessuna versione di Internet Explorer e nessuna versione precedente alla 75 di Edge supportano i SSE\cite{sse_support_caniuse}.

%%%%%%%%%%%%%%%%%%%%%%%%%
		% WebSockets
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{WebSockets}
I WebSocket sono un protocollo che permette una comunicazione full-duplex\footnote{in entrambe le direzioni e contemporaneamente} mediante una singola connessione TCP.
L'RFC 6455 afferma che WebSocket è progettato in modo da funzionare attraverso le porte HTTP 80 e 433 e di supportare proxy e intermediari HTTP, rendendolo dunque compatibile con il protocollo HTTP\cite{websockets_rfc}. Per poter essere compatibile, l'handshake tramite WebSocket fa uso dell'header \lstinline{Upgrade} di HTTP per cambiare protocollo da HTTP a WebSocket. Ciò è possibile perché entrambi i protocolli fanno parte dell'application layer nel modello OSI e dipendono da TCP.

\bigskip

Nei browser i WebSocket possono essere utilizzati mediante la \textit{WebSocket API}, anch'essa presente nell'HTML Living Standard di WHATWG.
Il flusso di comunicazione basato su WebSocket può essere espresso come segue\cite{websockets} ed illustrato in figura \ref{fig:websockets}:
\begin{enumerate}
  \item Il client tramite la chiamata API \lstinline{new WebSocket('/api/myEndpoint')} apre una nuova connessione HTTP, specificando nella richiesta gli header \lstinline{Upgrade: WebSocket} e \lstinline{Connection: Upgrade}.
  \item Il client registra le callback agli eventi \lstinline{onmessage}, \lstinline{onopen}, \lstinline{onclose} e \lstinline{onerror}.
  \item Il server risponde alla richiesta con codice \lstinline{101 Switching Protocols} e gestisce il socket aperto tramite protocollo WebSocket.
  \item Il client e il server possono finalmente scambiarsi messaggi in entrambe le direzioni.
\end{enumerate}
L'implementazione è molto simile a quella dei Server Sent Events:
\lstinputlisting[caption=Client side WebSocket example]{snippets/websocket_sample.js}

\begin{figure}[!htbp]
\centering
\includegraphics[width=.5\textwidth]{assets/websockets.png}
\caption{WebSockets Flow}
\label{fig:websockets}
\end{figure}
I WebSocket sono supportati da tutti i browser moderni. 
Sfortunatamente al momento della stesura non è possibile comunicare con i WebSocket tramite HTTP/2, in quanto non dispone del meccanismo di Upgrade di HTTP/1.1. Tuttavia i browser si stanno adoperando per supportare l'apertura di una comunicazione attraverso WebSocket su HTTP/2 seguendo il recente RCF 8441\cite{websockets_http2_rfc}. Ciò porterà a poter sfruttare il multiplexing offerto da HTTP/2 automaticamente anche con i WebSocket.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
							% Listen JS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Listen JS}
Il mio contributo nell'ambito dello sviluppo di web application real-time si concretizza in Listen JS, un insieme di librerie che permettono di osservare in tempo reale gli aggiornamenti ad una o più risorse.
Il progetto comprende anche un'applicazione di esempio che permette a più utenti di collaborare sull'inserimento, la modifica e la cancellazione di appuntamenti su un calendario tramite una web app.

\bigskip

Le librerie messe a disposizione sono rispettivamente \lstinline{listenjs} e \lstinline{listenjs-server}, la prima è una libreria client, utilizzabile su qualsiasi browser che supporti i WebSocket, la seconda è una libreria server utilizzabile su server sviluppati in NodeJS.
Entrambe le librerie sono volutamente framework-agnostic, cioè possono essere facilmente integrate in qualsiasi framework già esistente, sia front-end (e.g. Angular, React, VueJS...) che back-end (e.g. Express, Fastify, Koa...), e non sono opinionate rispetto ad alcun paradigma di programmazione. Utilizzando costrutti già presenti in Javascript, e non avendo dipendenze ad altre librerie, possono essere integrate in una codebase già esistente apportando pochissime modifiche.

\bigskip

Listen JS è volta a diminuire l'inerzia dell'implementazione di un'app real-time basata su WebSocket facilitandone l'utilizzo e riducendo il codice boilerplate. Inoltre fornisce una serie di funzionalità descritte nella sezione \ref{sec_features} per migliorare la gestione delle risorse, l'affidabilità e la semplicità d'utilizzo.
%%%%%%%%%%%%%%%%%%%%%%%%%
			% Struttura ad alto livello
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Struttura ad alto livello}\label{sec_struttura_alto_livello}
Le librerie utilizzano i WebSocket come layer di trasporto e astraggono la comunicazione scambiandosi dei messaggi predefiniti, ma che contengono payload definiti dall'utente.
La scelta di utilizzare i WebSocket come trasporto invece dei Server Sent Events è dovuta ai seguenti motivi:
\begin{enumerate}
\item I WebSocket sono supportati da tutti i browser moderni, a differenza dei Server Sent Events che (al momento della stesura) non sono supportati da Internet Explorer e alcune versioni di Edge.
\item Con i Server Sent Events non è possibile fare multiplexing utilizzando HTTP/1.1, in quanto non è possibile inviare messaggi successivi da client a server utilizzando la stessa connessione.
\item Poiché con i Server Sent Events non si possono inviare messaggi da client a server sulla stessa connessione, risulta difficile implementare meccanismi di ping personalizzati. È dunque complicato lato client verificare quando un server non è più raggiungibile.
\end{enumerate}

\subsection{Libreria client}
La libreria client permette con una linea di codice di rimanere in ascolto di qualsiasi risorsa negli endpoint che si desidera.

\subsubsection{Installazione}
La libreria client di ListenJS può essere aggiunta ad un progetto che sfrutti un module bundler (come per esempio WebPack) tramite il package manager NPM, eseguendo il comando:
\begin{center}
\lstinline{npm install @filippovigani/listenjs}
\end{center}
per poi essere importata o tramite CommonJS o gli import dei moduli di ES6:
\begin{center}
\lstinline{const listen = require('@filippovigani/listenjs').listen}
\end{center}
oppure
\begin{center}
\lstinline|import { listen, ... } from "@filippovigani/listenjs/listen"|
\end{center}  
Alternativamente è possibile scaricare direttamente il codice sorgente\cite{listenjs_repo} e importarlo nel progetto che si desidera.

\subsubsection{Utilizzo}
Per ogni risorsa per cui si vuole essere notificati degli aggiornamenti, basterà semplicemente chiamare la funzione per ascoltare uno specifico endpoint:
\lstinputlisting[caption=Listen JS client example]{snippets/listenjsclient_sample.js}
L'URI passato come argomento della funzione, può sia essere relativo, e quindi utilizzare lo stesso dominio della pagina di origine, oppure specificare un indirizzo completo, per esempio \lstinline{http://differentDomain.com/api/appointments}. Questo dominio per permettere al protocollo di WebSocket di fare l'handshake, dovrà avere abilitato i CORS (Cross-Origin Resource Sharing) in quanto la risorsa è su un'origine differente.

\subsection{Libreria server}
La libreria server permette di inizializzare un server che supporti i WebSocket e gestisce i client in ascolto sulle varie risorse, permettendo di notificare tutti i client in ascolto su una specifica risorsa. 
\subsubsection{Installazione}
Per aggiungere la libreria server di ListenJS ad un progetto NodeJS è sufficiente eseguire il comando:
\begin{center}
\lstinline{npm install @filippovigani/listenjs-server}
\end{center}
e per poterla utilizzare basta importarla come tutti i moduli di NodeJS
\begin{center}
\lstinline{const listen = require('@filippovigani/listenjs-server')}
\end{center}
Come per la parte client, è in alternativa possibile scaricare il codice sorgente\cite{listenjs_server_repo} e importarlo manualmente nel progetto.

\subsubsection{Utilizzo}
In fase di inizializzazione del server è necessario fare il binding di un server HTTP di NodeJS già esistente ListenJS, per poter inizializzare connessioni tramite WebSocket. Ciò si può fare chiamando la funzione \lstinline{setup} come segue: 
\lstinputlisting[caption=Listen JS server setup example]{snippets/listenjsserver_sample.js}
In caso fossero utilizzati framework per il routing degli endpoint, è sempre possibile reperire l'istanza del server HTTP sottostante per poter inizializzare ListenJS. Per esempio, utilizzando Fastify, ListenJS verrà inizializzato in questo modo:
\lstinputlisting[caption=Listen JS Fastify setup example]{snippets/listenjsserver_fastify_sample.js}
Per qualsiasi altro framework si può trovare nella documentazione come reperire il server HTTP.

\bigskip

Una volta inizializzato, è possibile notificare i client che sono in ascolto di una risorsa tramite la funzione \lstinline{notify}. Per esempio, in un endpoint POST, il codice per notificare tutti i client in ascolto su una risorsa è il seguente:
\lstinputlisting[caption=Listen JS server notify example]{snippets/listenjsserver_notify_sample.js}

La libreria si occuperà di inviare un messaggio contentente il nuovo payload a tutti e soli i client in ascolto. Se non ci fosse nessun client in ascolto su quella specifica risorsa, la chiamata non avrà alcun effetto.

%%%%%%%%%%%%%%%%%%%%%%%%%
			% Features
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Features}\label{sec_features}
Oltre a permettere...
\subsection{Disconnection detection}

\subsection{Reconnection}

\subsection{Multiplexing}

\subsection{Observer pattern across the stack}

\subsection{Semplificazione utilizzo WebSocket}

%%%%%%%%%%%%%%%%%%%%%%%%%
			% Struttura a basso livello
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Struttura a basso livello}\label{sec_struttura_basso_livello}
Il funzionamento del sistema si basa sullo scambio dei messaggi che hanno la seguente struttura:
\subsection{Architettura}
E messaggi di scambio

\subsection{Implementazione multiplexing}

\subsection{Implementazione disconnection detection}
ping/keep alive
\subsection{Implementazione reconnection}
backoff

\subsection{Implementazione observer pattern}

%%%%%%%%%%%%%%%%%%%%%%%%%
			% Applicazione di esempio
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Applicazione di esempio}\label{sec_applicazioneesempio}
CORS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
							% Valutazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Valutazione}

%%%%%%%%%%%%%%%%%%%%%%%%%
			% Confronto tra XHR polling e WebSocket
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Confronto tra XHR polling e websockets}\label{sec_confrontopollingwebsockets}

\subsection{Responsiveness}

\subsection{Traffico dati}

\subsection{User experience}
Tradeoff

%%%%%%%%%%%%%%%%%%%%%%%%%
			% Valore aggiunto di Listen JS
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Valore aggiunto di Listen JS}\label{sec_valorelistenjs}

\subsection{Utilizzo risorse e limitazioni browser}
Limite socket aperti contemporaneamente

\subsection{Immediatezza integrazione da parte di sviluppatori}

\subsection{Architettura}
Separation of Concerns

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
						% Conclusioni
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter*{Conclusioni}
\rhead[\fancyplain{}{\bfseries
Conclusioni}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
Conclusioni}}
\addcontentsline{toc}{chapter}{Conclusioni}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
							% Sviluppi futuri
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Sviluppi futuri}
SSL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
							% Bibliografia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}

\rhead[\fancyplain{}{\bfseries
Bibliografia}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
Bibliografia}}

\bibliographystyle{unsrt}
\bibliography{bibliografia}
\addcontentsline{toc}{chapter}{Bibliografia}

\end{document}
